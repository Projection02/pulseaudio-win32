From 3e25facff7148884202518d75f684386e4a8527c Mon Sep 17 00:00:00 2001
From: Patrick Gaskin <patrick@pgaskin.net>
Date: Thu, 22 Apr 2021 08:05:10 -0400
Subject: [PATCH] daemon: Add support for running as a service on win32

* Minimal implementation of --system on win32.
* Wrap main with a Windows Service on win32 (with a fallback to
  running it directly).
* Update PA_SYSTEM_{RUNTIME,STATE,CONFIG}_PATH and HOME dynamically
  on Windows (overrides the build config, similar to the existing
  config path replacement logic).
---
 src/daemon/main.c         | 125 +++++++++++++++++++++++++++++++++++++-
 src/pulse/context.c       |   7 +++
 src/pulsecore/core-util.c |  10 +++
 src/pulsecore/core-util.h |   1 +
 4 files changed, 141 insertions(+), 2 deletions(-)

diff --git a/src/daemon/main.c b/src/daemon/main.c
index a424d9ef9..e259b3704 100644
--- a/src/daemon/main.c
+++ b/src/daemon/main.c
@@ -60,6 +60,10 @@
 #include <systemd/sd-daemon.h>
 #endif
 
+#ifdef HAVE_WINDOWS_H
+#include <windows.h>
+#endif
+
 #include <pulse/client-conf.h>
 #include <pulse/mainloop.h>
 #include <pulse/mainloop-signal.h>
@@ -156,7 +160,33 @@ static void signal_callback(pa_mainloop_api* m, pa_signal_event *e, int sig, voi
     }
 }
 
-#if defined(HAVE_PWD_H) && defined(HAVE_GRP_H)
+
+#if defined(OS_IS_WIN32)
+
+static int change_user(void) {
+    pa_log_info("Overriding system runtime/config base dir to '%s'.", pa_win32_get_system_appdata());
+
+    char *run_path = pa_sprintf_malloc("%s" PA_PATH_SEP "run", pa_win32_get_system_appdata());
+    char *lib_path = pa_sprintf_malloc("%s" PA_PATH_SEP "lib", pa_win32_get_system_appdata());
+
+    // TODO: figure out dir ACLs
+
+    pa_set_env("HOME", run_path);
+    if (!getenv("PULSE_RUNTIME_PATH"))
+        pa_set_env("PULSE_RUNTIME_PATH", run_path);
+    if (!getenv("PULSE_CONFIG_PATH"))
+        pa_set_env("PULSE_CONFIG_PATH", lib_path);
+    if (!getenv("PULSE_STATE_PATH"))
+        pa_set_env("PULSE_STATE_PATH", lib_path);
+
+    pa_xfree(run_path);
+    pa_xfree(lib_path);
+
+    pa_log_info("Not changing user for system instance on Windows."); // TODO: maybe drop privileges, figure out pulse paths
+    return 0;
+}
+
+#elif defined(HAVE_PWD_H) && defined(HAVE_GRP_H)
 
 static int change_user(void) {
     struct passwd *pw;
@@ -377,7 +407,45 @@ fail:
 }
 #endif
 
-int main(int argc, char *argv[]) {
+#ifdef OS_IS_WIN32
+#define SVC_NAME "PulseAudio"
+static bool is_svc = true;
+static int argc;
+static char **argv;
+static int real_main(int s_argc, char *s_argv[]);
+static SERVICE_STATUS_HANDLE svc_status;
+
+DWORD svc_callback(DWORD ctl, DWORD evt, LPVOID data, LPVOID userdata) {
+    pa_mainloop **m = userdata;
+    switch (ctl) {
+    case SERVICE_CONTROL_STOP:
+    case SERVICE_CONTROL_SHUTDOWN:
+        if (m) {
+            pa_log_info("Exiting.");
+            pa_mainloop_get_api(*m)->quit(pa_mainloop_get_api(*m), 0);
+        }
+        return NO_ERROR;
+    case SERVICE_CONTROL_INTERROGATE:
+        return NO_ERROR;
+    }
+    return ERROR_CALL_NOT_IMPLEMENTED;
+}
+
+int main(int p_argc, char *p_argv[]) {
+    argc = p_argc;
+    argv = p_argv;
+    if (StartServiceCtrlDispatcherA((SERVICE_TABLE_ENTRYA[]){
+        {SVC_NAME, (LPSERVICE_MAIN_FUNCTIONA) real_main},
+        {0},
+    })) return 0;
+    is_svc = false;
+    return real_main(0, NULL);
+}
+
+static int real_main(int s_argc, char *s_argv[]) {
+#else
+int main(int s_argc, char *s_argv[]) {
+#endif
     pa_core *c = NULL;
     pa_strbuf *buf = NULL;
     pa_daemon_conf *conf = NULL;
@@ -402,6 +470,23 @@ int main(int argc, char *argv[]) {
     bool start_server;
 #endif
 
+#ifdef OS_IS_WIN32
+    if (is_svc && !(svc_status = RegisterServiceCtrlHandlerExA(SVC_NAME, (LPHANDLER_FUNCTION_EX) svc_callback, &mainloop))) {
+        pa_log("Failed to register service control handler.");
+        goto finish;
+    }
+
+    if (is_svc) {
+        SetServiceStatus(svc_status, &(SERVICE_STATUS){
+            .dwServiceType      = SERVICE_WIN32,
+            .dwCurrentState     = SERVICE_START_PENDING,
+            .dwControlsAccepted = 0,
+            .dwWin32ExitCode    = NO_ERROR,
+            .dwWaitHint         = 3000,
+        });
+    }
+#endif
+
     pa_log_set_ident("pulseaudio");
     pa_log_set_level(PA_LOG_NOTICE);
     pa_log_set_flags(PA_LOG_COLORS|PA_LOG_PRINT_FILE|PA_LOG_PRINT_LEVEL, PA_LOG_RESET);
@@ -1172,6 +1257,18 @@ int main(int argc, char *argv[]) {
     sd_notify(0, "READY=1");
 #endif
 
+#ifdef OS_IS_WIN32
+    if (is_svc) {
+        SetServiceStatus(svc_status, &(SERVICE_STATUS){
+            .dwServiceType      = SERVICE_WIN32,
+            .dwCurrentState     = SERVICE_RUNNING,
+            .dwControlsAccepted = SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_SHUTDOWN,
+            .dwWin32ExitCode    = NO_ERROR,
+            .dwWaitHint         = 0,
+        });
+    }
+#endif
+
     retval = 0;
     if (pa_mainloop_run(mainloop, &retval) < 0)
         goto finish;
@@ -1182,6 +1279,18 @@ int main(int argc, char *argv[]) {
     sd_notify(0, "STOPPING=1");
 #endif
 
+#ifdef OS_IS_WIN32
+    if (is_svc) {
+        SetServiceStatus(svc_status, &(SERVICE_STATUS){
+            .dwServiceType      = SERVICE_WIN32,
+            .dwCurrentState     = SERVICE_STOP_PENDING,
+            .dwControlsAccepted = 0,
+            .dwWin32ExitCode    = NO_ERROR,
+            .dwWaitHint         = 2000,
+        });
+    }
+#endif
+
 finish:
 #ifdef HAVE_DBUS
     if (server_bus)
@@ -1249,5 +1358,17 @@ finish:
     dbus_shutdown();
 #endif
 
+#ifdef OS_IS_WIN32
+    if (is_svc) {
+        SetServiceStatus(svc_status, &(SERVICE_STATUS){
+            .dwServiceType      = SERVICE_WIN32,
+            .dwCurrentState     = SERVICE_STOPPED,
+            .dwControlsAccepted = 0,
+            .dwWin32ExitCode    = retval ? ERROR_PROCESS_ABORTED : NO_ERROR,
+            .dwWaitHint         = 0,
+        });
+    }
+#endif
+
     return retval;
 }
diff --git a/src/pulse/context.c b/src/pulse/context.c
index b0a838860..e535d044f 100644
--- a/src/pulse/context.c
+++ b/src/pulse/context.c
@@ -1035,7 +1035,14 @@ int pa_context_connect(
         }
 
         /* The system wide instance via PF_LOCAL */
+#ifndef OS_IS_WIN32
         c->server_list = pa_strlist_prepend(c->server_list, PA_SYSTEM_RUNTIME_PATH PA_PATH_SEP PA_NATIVE_DEFAULT_UNIX_SOCKET);
+#else
+        /* see change_user in src/daemon/main.c */
+        char *run_path = pa_sprintf_malloc("%s" PA_PATH_SEP "run" PA_PATH_SEP PA_NATIVE_DEFAULT_UNIX_SOCKET, pa_win32_get_system_appdata());
+        c->server_list = pa_strlist_prepend(c->server_list, run_path);
+        pa_xfree(run_path);
+#endif
 
         /* The user instance via PF_LOCAL */
         c->server_list = prepend_per_user(c->server_list);
diff --git a/src/pulsecore/core-util.c b/src/pulsecore/core-util.c
index d7bdfac1d..96cdcef80 100644
--- a/src/pulsecore/core-util.c
+++ b/src/pulsecore/core-util.c
@@ -83,6 +83,7 @@
 
 #ifdef HAVE_WINDOWS_H
 #include <windows.h>
+#include <shlobj.h>
 #endif
 
 #ifndef ENOTSUP
@@ -171,6 +172,15 @@ char *pa_win32_get_toplevel(HANDLE handle) {
     return toplevel;
 }
 
+char *pa_win32_get_system_appdata() {
+    static char appdata[MAX_PATH] = {0};
+
+    if (!*appdata && SHGetFolderPathAndSubDirA(NULL, CSIDL_COMMON_APPDATA|CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, "PulseAudio", appdata) != S_OK)
+        return NULL;
+
+    return appdata;
+}
+
 #endif
 
 static void set_nonblock(int fd, bool nonblock) {
diff --git a/src/pulsecore/core-util.h b/src/pulsecore/core-util.h
index ed123c796..a69d53be8 100644
--- a/src/pulsecore/core-util.h
+++ b/src/pulsecore/core-util.h
@@ -310,6 +310,7 @@ bool pa_running_in_vm(void);
 
 #ifdef OS_IS_WIN32
 char *pa_win32_get_toplevel(HANDLE handle);
+char *pa_win32_get_system_appdata();
 #endif
 
 size_t pa_page_size(void);
-- 
2.31.0

